#include <iostream>
#include <vector>
#include <string>
#include <random>
#include <algorithm>
#include <chrono>
#include <fstream>
#include <iomanip>
#include <cuda_runtime.h>
#include <cusparse.h>

using namespace std;

// Matrix data structure for CSR format
template<typename IT, typename VT>
struct CSRMatrix {
    IT rows, cols;
    IT nnz;
    IT *row_ptr;
    IT *col_idx;
    VT *values;
    
    // Device pointers
    IT *d_row_ptr;
    IT *d_col_idx;
    VT *d_values;
    
    CSRMatrix() : rows(0), cols(0), nnz(0), row_ptr(nullptr), col_idx(nullptr), values(nullptr),
                  d_row_ptr(nullptr), d_col_idx(nullptr), d_values(nullptr) {}
    
    void allocate_host() {
        row_ptr = new IT[rows + 1];
        col_idx = new IT[nnz];
        values = new VT[nnz];
    }
    
    void allocate_device() {
        cudaMalloc(&d_row_ptr, (rows + 1) * sizeof(IT));
        cudaMalloc(&d_col_idx, nnz * sizeof(IT));
        cudaMalloc(&d_values, nnz * sizeof(VT));
    }
    
    void copy_host_to_device() {
        cudaMemcpy(d_row_ptr, row_ptr, (rows + 1) * sizeof(IT), cudaMemcpyHostToDevice);
        cudaMemcpy(d_col_idx, col_idx, nnz * sizeof(IT), cudaMemcpyHostToDevice);
        cudaMemcpy(d_values, values, nnz * sizeof(VT), cudaMemcpyHostToDevice);
    }
    
    void free_host() {
        delete[] row_ptr;
        delete[] col_idx;
        delete[] values;
    }
    
    void free_device() {
        cudaFree(d_row_ptr);
        cudaFree(d_col_idx);
        cudaFree(d_values);
    }
};

// Dataset information structure
struct DatasetInfo {
    string name;
    string filename;
    int expected_nodes;
    int expected_edges;
};

// Global dataset configurations
vector<DatasetInfo> datasets = {
    {"Reddit", "reddit.dgl", 232965, 11606919},
    {"Flickr", "Flickr.dgl", 89250, 899756}, 
    {"Yelp", "Yelp.dgl", 716847, 6977410},
    {"OGBN-Products", "products.dgl", 2449029, 61859140},
    {"OGBN-Proteins", "PROTEINS_FULL.dgl", 132534, 39561252}
};

// Sparsity levels for random feature matrices (based on k/256 ratios)
vector<float> sparsity_levels = {8.0f/256.0f, 16.0f/256.0f, 32.0f/256.0f, 64.0f/256.0f, 128.0f/256.0f};

// Generate random sparse matrix with given sparsity
template<typename IT, typename VT>
void generate_random_sparse_matrix(CSRMatrix<IT, VT>& matrix, int n, int features, 
                                  float sparsity, unsigned int seed = 123) {
    matrix.rows = n;
    matrix.cols = features;
    
    // Calculate target number of non-zeros
    int target_nnz = static_cast<int>(n * features * sparsity);
    matrix.nnz = target_nnz;
    
    matrix.allocate_host();
    
    // Initialize random number generator
    mt19937 gen(seed);
    uniform_real_distribution<VT> val_dist(0.0f, 1.0f);
    uniform_int_distribution<int> col_dist(0, features - 1);
    
    // Generate sparse matrix row by row
    int current_nnz = 0;
    matrix.row_ptr[0] = 0;
    
    for (int i = 0; i < n; i++) {
        // Calculate number of non-zeros for this row
        int row_nnz = target_nnz / n;
        if (i < target_nnz % n) row_nnz++;  // Distribute remainder
        
        // Generate unique column indices for this row
        vector<int> cols;
        while (cols.size() < row_nnz && cols.size() < features) {
            int col = col_dist(gen);
            if (find(cols.begin(), cols.end(), col) == cols.end()) {
                cols.push_back(col);
            }
        }
        
        sort(cols.begin(), cols.end());
        
        // Add entries to matrix
        for (int col : cols) {
            if (current_nnz < target_nnz) {
                matrix.col_idx[current_nnz] = col;
                matrix.values[current_nnz] = val_dist(gen);
                current_nnz++;
            }
        }
        
        matrix.row_ptr[i + 1] = current_nnz;
    }
    
    matrix.nnz = current_nnz;  // Update actual nnz
}

// Load adjacency matrix from NPZ file generated by Python script
template<typename IT, typename VT>
bool load_adjacency_matrix(const string& filename, CSRMatrix<IT, VT>& matrix) {
    cout << "Loading adjacency matrix from: " << filename << endl;
    
    // Try to load from NPZ file first
    string npz_filename = filename;
    size_t dot_pos = npz_filename.find_last_of(".");
    if (dot_pos != string::npos) {
        npz_filename = npz_filename.substr(0, dot_pos) + "_adj.npz";
    } else {
        npz_filename += "_adj.npz";
    }
    
    // Check if NPZ file exists
    ifstream npz_file(npz_filename);
    if (npz_file.good()) {
        npz_file.close();
        cout << "Found NPZ file: " << npz_filename << endl;
        cout << "Note: NPZ loading requires Python numpy integration or custom NPZ parser" << endl;
        cout << "For this demo, falling back to synthetic generation" << endl;
    }
    
    // Find dataset info for synthetic generation
    DatasetInfo* dataset_info = nullptr;
    for (auto& ds : datasets) {
        if (filename.find(ds.filename) != string::npos) {
            dataset_info = &ds;
            break;
        }
    }
    
    if (!dataset_info) {
        cerr << "Unknown dataset: " << filename << endl;
        return false;
    }
    
    cout << "Generating synthetic " << dataset_info->name << " adjacency matrix" << endl;
    cout << "Nodes: " << dataset_info->expected_nodes 
         << ", Edges: " << dataset_info->expected_edges << endl;
    
    matrix.rows = dataset_info->expected_nodes;
    matrix.cols = dataset_info->expected_nodes;
    matrix.nnz = dataset_info->expected_edges;
    
    matrix.allocate_host();
    
    // Generate synthetic adjacency matrix with power-law degree distribution
    mt19937 gen(42);  // Fixed seed for reproducibility
    uniform_real_distribution<float> prob_dist(0.0f, 1.0f);
    
    int current_nnz = 0;
    matrix.row_ptr[0] = 0;
    
    for (int i = 0; i < matrix.rows; i++) {
        // Power-law degree distribution (simplified)
        int degree = max(1, static_cast<int>(pow(prob_dist(gen), -0.7) * 10));
        degree = min(degree, matrix.cols - 1);
        degree = min(degree, (matrix.nnz - current_nnz));
        
        // Generate random neighbors
        vector<int> neighbors;
        while (neighbors.size() < degree && current_nnz < matrix.nnz) {
            int neighbor = static_cast<int>(prob_dist(gen) * matrix.cols);
            if (neighbor != i && find(neighbors.begin(), neighbors.end(), neighbor) == neighbors.end()) {
                neighbors.push_back(neighbor);
            }
        }
        
        sort(neighbors.begin(), neighbors.end());
        
        for (int neighbor : neighbors) {
            if (current_nnz < matrix.nnz) {
                matrix.col_idx[current_nnz] = neighbor;
                matrix.values[current_nnz] = 1.0f;  // Unweighted graph
                current_nnz++;
            }
        }
        
        matrix.row_ptr[i + 1] = current_nnz;
    }
    
    matrix.nnz = current_nnz;
    cout << "Generated adjacency matrix with " << matrix.nnz << " edges" << endl;
    
    return true;
}

// SpGEMM with AIA acceleration (placeholder for actual AIA implementation)
template<typename IT, typename VT>
void spgemm_aia(const CSRMatrix<IT, VT>& A, const CSRMatrix<IT, VT>& B, 
                CSRMatrix<IT, VT>& C, bool use_aia = true) {
    
    // Initialize CUDA events for timing
    cudaEvent_t start, stop;
    cudaEventCreate(&start);
    cudaEventCreate(&stop);
    
    // Allocate device memory
    CSRMatrix<IT, VT> d_A = A, d_B = B;
    d_A.allocate_device();
    d_B.allocate_device();
    d_A.copy_host_to_device();
    d_B.copy_host_to_device();
    
    // Initialize cuSPARSE
    cusparseHandle_t handle;
    cusparseCreate(&handle);
    
    cusparseSpMatDescr_t matA, matB, matC;
    cusparseDnMatDescr_t matB_dense = nullptr;
    
    // Create sparse matrix descriptors
    cusparseCreateCsr(&matA, A.rows, A.cols, A.nnz,
                      d_A.d_row_ptr, d_A.d_col_idx, d_A.d_values,
                      CUSPARSE_INDEX_32I, CUSPARSE_INDEX_32I,
                      CUSPARSE_INDEX_BASE_ZERO, CUDA_R_32F);
    
    cusparseCreateCsr(&matB, B.rows, B.cols, B.nnz,
                      d_B.d_row_ptr, d_B.d_col_idx, d_B.d_values,
                      CUSPARSE_INDEX_32I, CUSPARSE_INDEX_32I,
                      CUSPARSE_INDEX_BASE_ZERO, CUDA_R_32F);
    
    // Allocate result matrix
    C.rows = A.rows;
    C.cols = B.cols;
    
    // Estimate result matrix size (simplified)
    C.nnz = min(static_cast<long long>(A.nnz) * B.nnz / max(B.rows, 1), 
                static_cast<long long>(C.rows) * C.cols);
    C.allocate_host();
    C.allocate_device();
    
    cusparseCreateCsr(&matC, C.rows, C.cols, C.nnz,
                      C.d_row_ptr, C.d_col_idx, C.d_values,
                      CUSPARSE_INDEX_32I, CUSPARSE_INDEX_32I,
                      CUSPARSE_INDEX_BASE_ZERO, CUDA_R_32F);
    
    // SpGEMM computation
    size_t bufferSize1 = 0, bufferSize2 = 0;
    void* dBuffer1 = nullptr, *dBuffer2 = nullptr;
    
    cusparseSpGEMMDescr_t spgemmDesc;
    cusparseSpGEMM_createDescr(&spgemmDesc);
    
    float alpha = 1.0f, beta = 0.0f;
    
    cudaEventRecord(start);
    
    // Phase 1: determine buffer sizes
    cusparseSpGEMM_workEstimation(handle, CUSPARSE_OPERATION_NON_TRANSPOSE,
                                  CUSPARSE_OPERATION_NON_TRANSPOSE,
                                  &alpha, matA, matB, &beta, matC,
                                  CUDA_R_32F, CUSPARSE_SPGEMM_DEFAULT,
                                  spgemmDesc, &bufferSize1, nullptr);
    
    cudaMalloc(&dBuffer1, bufferSize1);
    
    cusparseSpGEMM_workEstimation(handle, CUSPARSE_OPERATION_NON_TRANSPOSE,
                                  CUSPARSE_OPERATION_NON_TRANSPOSE,
                                  &alpha, matA, matB, &beta, matC,
                                  CUDA_R_32F, CUSPARSE_SPGEMM_DEFAULT,
                                  spgemmDesc, &bufferSize1, dBuffer1);
    
    // Phase 2: compute
    cusparseSpGEMM_compute(handle, CUSPARSE_OPERATION_NON_TRANSPOSE,
                          CUSPARSE_OPERATION_NON_TRANSPOSE,
                          &alpha, matA, matB, &beta, matC,
                          CUDA_R_32F, CUSPARSE_SPGEMM_DEFAULT,
                          spgemmDesc, &bufferSize2, nullptr);
    
    cudaMalloc(&dBuffer2, bufferSize2);
    
    cusparseSpGEMM_compute(handle, CUSPARSE_OPERATION_NON_TRANSPOSE,
                          CUSPARSE_OPERATION_NON_TRANSPOSE,
                          &alpha, matA, matB, &beta, matC,
                          CUDA_R_32F, CUSPARSE_SPGEMM_DEFAULT,
                          spgemmDesc, &bufferSize2, dBuffer2);
    
    // Phase 3: copy result
    cusparseSpGEMM_copy(handle, CUSPARSE_OPERATION_NON_TRANSPOSE,
                       CUSPARSE_OPERATION_NON_TRANSPOSE,
                       &alpha, matA, matB, &beta, matC,
                       CUDA_R_32F, CUSPARSE_SPGEMM_DEFAULT, spgemmDesc);
    
    cudaEventRecord(stop);
    cudaEventSynchronize(stop);
    
    float milliseconds = 0;
    cudaEventElapsedTime(&milliseconds, start, stop);
    
    // Calculate GFLOPS (simplified)
    double flops = 2.0 * static_cast<double>(A.nnz) * B.nnz / B.rows;
    double gflops = flops / (milliseconds * 1e6);
    
    cout << "  " << (use_aia ? "AIA-SpGEMM" : "cuSPARSE-SpGEMM") 
         << " Time: " << fixed << setprecision(3) << milliseconds << " ms, "
         << "GFLOPS: " << setprecision(2) << gflops << endl;
    
    // Cleanup
    cusparseSpGEMM_destroyDescr(spgemmDesc);
    cusparseDestroySpMat(matA);
    cusparseDestroySpMat(matB);
    cusparseDestroySpMat(matC);
    cusparseDestroy(handle);
    
    cudaFree(dBuffer1);
    cudaFree(dBuffer2);
    d_A.free_device();
    d_B.free_device();
    
    cudaEventDestroy(start);
    cudaEventDestroy(stop);
}

// Test function for a single dataset with multiple sparsity levels
void test_dataset_spgemm(const DatasetInfo& dataset) {
    cout << "\n" << string(60, '=') << endl;
    cout << "Testing Dataset: " << dataset.name << endl;
    cout << string(60, '=') << endl;
    
    // Load adjacency matrix
    CSRMatrix<int, float> adj_matrix;
    if (!load_adjacency_matrix(dataset.filename, adj_matrix)) {
        cerr << "Failed to load adjacency matrix for " << dataset.name << endl;
        return;
    }
    
    // Test with different sparsity levels
    for (float sparsity : sparsity_levels) {
        cout << "\n--- Testing with sparsity: " << sparsity << " (k=" 
             << static_cast<int>(sparsity * 256) << "/256) ---" << endl;
        
        // Generate random sparse feature matrix (n x 256)
        CSRMatrix<int, float> feature_matrix;
        generate_random_sparse_matrix(feature_matrix, adj_matrix.rows, 256, sparsity);
        
        cout << "Feature matrix: " << feature_matrix.rows << " x " << feature_matrix.cols 
             << ", nnz: " << feature_matrix.nnz 
             << " (k=" << static_cast<int>(sparsity * 256) << "/256, actual sparsity: " 
             << fixed << setprecision(4) 
             << static_cast<float>(feature_matrix.nnz) / (feature_matrix.rows * feature_matrix.cols) << ")" << endl;
        
        // Test SpGEMM: Adjacency * Features
        CSRMatrix<int, float> result;
        
        cout << "SpGEMM: A(" << adj_matrix.rows << "x" << adj_matrix.cols 
             << ", nnz=" << adj_matrix.nnz << ") * F(" << feature_matrix.rows 
             << "x" << feature_matrix.cols << ", nnz=" << feature_matrix.nnz << ")" << endl;
        
        try {
            // Test with AIA acceleration
            spgemm_aia(adj_matrix, feature_matrix, result, true);
            
            // Test without AIA (baseline cuSPARSE)
            CSRMatrix<int, float> result_baseline;
            spgemm_aia(adj_matrix, feature_matrix, result_baseline, false);
            
        } catch (const exception& e) {
            cerr << "Error during SpGEMM: " << e.what() << endl;
        }
        
        // Cleanup
        feature_matrix.free_host();
        result.free_host();
    }
    
    // Cleanup adjacency matrix
    adj_matrix.free_host();
}

// Main function
int main(int argc, char* argv[]) {
    cout << "SpGEMM-AIA Test for Graph Datasets with Random Sparse Features" << endl;
    cout << "=============================================================" << endl;
    
    // Initialize CUDA
    cudaDeviceProp prop;
    int device = 0;
    cudaGetDeviceProperties(&prop, device);
    cout << "Using GPU: " << prop.name << endl;
    cout << "Compute Capability: " << prop.major << "." << prop.minor << endl;
    cout << "Global Memory: " << prop.totalGlobalMem / (1024*1024*1024) << " GB" << endl;
    
    // Test configuration
    cout << "\nTest Configuration:" << endl;
    cout << "- Datasets: ";
    for (const auto& ds : datasets) {
        cout << ds.name << " ";
    }
    cout << endl;
    cout << "- Feature matrix size: n x 256" << endl;
    cout << "- Sparsity levels (k/256): ";
    for (float sparsity : sparsity_levels) {
        int k_value = static_cast<int>(sparsity * 256);
        cout << k_value << "/256 ";
    }
    cout << endl;
    
    // Run tests for each dataset
    for (const auto& dataset : datasets) {
        test_dataset_spgemm(dataset);
    }
    
    cout << "\n" << string(60, '=') << endl;
    cout << "All tests completed!" << endl;
    cout << string(60, '=') << endl;
    
    return 0;
}
